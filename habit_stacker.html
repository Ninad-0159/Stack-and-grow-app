<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stack & Grow - Dark Theme</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        html { font-family: 'Inter', sans-serif; scroll-behavior: smooth; }
        
        /* Define the consistent CYAN to BLUE gradient for the header in both states */
        .hero-bg-pro, .hero-bg-free { 
            background-image: linear-gradient(to right bottom, #06b6d4, #3b82f6); /* Cyan-500 to Blue-500 */
        }

        /* Dark Theme overrides for elements */
        .bg-page { background-color: #111827; /* Gray-900 */ }
        .bg-card { background-color: #1f2937; /* Gray-800 */ }
        .input-style { 
            background-color: #374151; /* Gray-700 */
            border-color: #4b5563; /* Gray-600 */
            color: white;
            transition: all 0.2s;
        }
        .input-style:focus {
            border-color: #06b6d4; /* Cyan-500 */
            ring-color: #06b6d4;
        }

        /* Styling for locked/pro content */
        .pro-overlay {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(17, 24, 39, 0.9); /* Dark overlay with high opacity */
            backdrop-filter: blur(4px);
            border-radius: 0.75rem;
            text-align: center;
            z-index: 10;
            cursor: pointer;
        }

        /* Dark Theme Ad Container */
        .ad-container {
            border: 2px dashed #fcd34d; /* Amber 400 */
            background-color: #451a03; /* Amber 950 */
            color: #fde68a; /* Amber 200 */
        }
    </style>
</head>
<body class="bg-page min-h-screen text-white antialiased">

    <!-- Firebase Imports and Setup (MANDATORY) -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, addDoc, deleteDoc, updateDoc, onSnapshot, collection, query, setDoc, getDoc, setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        
        setLogLevel('Debug');

        // CONSTANTS
        const MAX_FREE_STACKS = 5; 
        const PRIMARY_COLOR = '#06b6d4'; // Cyan-500
        const PRO_PRICE = '$1.00'; 

        // Global Firebase Variables
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : null;
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        let db, auth, userId = null;
        let isAuthReady = false;
        window.userAccountType = 'free'; // Default state
        window.habitStacks = [];
        
        // Custom Modal Logic (Required: Cannot use alert/confirm)
        const showModal = (title, message, confirmAction = null, isConfirm = false) => {
            const modal = document.getElementById('customModal');
            const modalTitle = document.getElementById('modalTitle');
            const modalBody = document.getElementById('modalBody');
            const modalFooter = document.getElementById('modalFooter');

            modalTitle.textContent = title;
            modalBody.innerHTML = message;

            modalFooter.innerHTML = '';
            
            if (isConfirm) {
                const cancelBtn = document.createElement('button');
                cancelBtn.textContent = 'Cancel';
                cancelBtn.className = 'px-4 py-2 bg-gray-600 text-white rounded-lg hover:bg-gray-700 transition';
                cancelBtn.onclick = closeModal;
                
                const confirmBtn = document.createElement('button');
                confirmBtn.textContent = 'Confirm';
                confirmBtn.className = 'px-4 py-2 bg-cyan-600 text-white rounded-lg hover:bg-cyan-700 transition';
                confirmBtn.onclick = () => {
                    if (confirmAction) confirmAction();
                    closeModal(); // Close after action
                };
                
                modalFooter.appendChild(cancelBtn);
                modalFooter.appendChild(confirmBtn);
            } else {
                const closeBtn = document.createElement('button');
                closeBtn.textContent = 'Close';
                closeBtn.className = 'px-4 py-2 bg-cyan-600 text-white rounded-lg hover:bg-cyan-700 transition';
                closeBtn.onclick = closeModal;
                modalFooter.appendChild(closeBtn);
            }

            modal.classList.remove('hidden');
        };

        const closeModal = () => {
            document.getElementById('customModal').classList.add('hidden');
        };

        // --- Firebase Initialization ---
        if (firebaseConfig) {
            const app = initializeApp(firebaseConfig);
            db = getFirestore(app);
            auth = getAuth(app);

            // 1. Authentication Setup
            onAuthStateChanged(auth, async (user) => {
                const userIdDisplay = document.getElementById('userIdDisplay');
                const generateButton = document.getElementById('generateStackButton');

                if (user) {
                    userId = user.uid;
                    isAuthReady = true;
                    userIdDisplay.textContent = userId;
                    generateButton.innerHTML = `<svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6v6m0 0v6m0-6h6m-6 0H6"></path></svg>Generate & Start Tracking`;
                    
                    await loadUserAccountType(); // Load status first
                    startHabitListener(); // Then start listening for stacks
                } else {
                    try {
                        if (initialAuthToken) {
                            await signInWithCustomToken(auth, initialAuthToken);
                        } else {
                            // Anonymous sign-in if no token is available
                            await signInAnonymously(auth);
                        }
                    } catch (error) {
                        console.error("Firebase Sign-in Failed:", error);
                        userIdDisplay.textContent = 'Auth Failed';
                    } finally {
                         // IMPORTANT: Always set isAuthReady to true once the attempt is made
                        isAuthReady = true; 
                        if (!userId) {
                            // If sign-in failed, still update button state to indicate readiness
                            generateButton.innerHTML = `<svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6v6m0 0v6m0-6h6m-6 0H6"></path></svg>Generate & Start Tracking`;
                        }
                    }
                }
            });
        } else {
            console.error("Firebase config is missing. Data persistence disabled.");
        }

        // --- Firestore Utility Functions ---

        function getUserDataDocRef() {
            // Path: /artifacts/{appId}/users/{userId}/user_data/account
            const currentUserId = auth.currentUser?.uid || 'anonymous';
            return doc(db, `artifacts/${appId}/users/${currentUserId}/user_data/account`);
        }

        function getStacksCollectionRef() {
            // Path: /artifacts/{appId}/users/{userId}/stacks
            const currentUserId = auth.currentUser?.uid || 'anonymous';
            return collection(db, `artifacts/${appId}/users/${currentUserId}/stacks`);
        }

        /**
         * Loads the user's account type from Firestore.
         */
        async function loadUserAccountType() {
            if (!isAuthReady || !db) return;
            try {
                const docRef = getUserDataDocRef();
                const docSnap = await getDoc(docRef);
                if (docSnap.exists()) {
                    window.userAccountType = docSnap.data().accountType || 'free';
                } else {
                    // Set initial account type if document doesn't exist
                    await setDoc(docRef, { accountType: 'free' });
                    window.userAccountType = 'free';
                }
                updateAppTheme();
                window.renderStacks(); // Ensure rendering happens after auth
            } catch (error) {
                console.error("Error loading account type:", error);
            }
        }
        
        /**
         * Simulates upgrading/downgrading the user's account.
         */
        window.performProUpgrade = async () => {
            if (!isAuthReady || !db) {
                showModal('Error', 'Authentication not ready. Please wait.');
                return;
            }

            try {
                const docRef = getUserDataDocRef();
                await setDoc(docRef, { accountType: 'pro' }, { merge: true });
                window.userAccountType = 'pro';
                updateAppTheme();
                window.renderStacks();
                showModal('PRO UNLOCKED!', `<p class="text-green-400 font-bold">Thank you for subscribing!</p><p>You now have unlimited stacks, streak tracking, and an ad-free experience for only ${PRO_PRICE}/month.</p>`, null, false);
            } catch (error) {
                showModal('Error', `Failed to update PRO status: ${error.message}`);
            }
        };

        /**
         * Handles downgrading the user's account.
         */
        window.performFreeDowngrade = async () => {
             if (!isAuthReady || !db) {
                showModal('Error', 'Authentication not ready. Please wait.');
                return;
            }

            try {
                const docRef = getUserDataDocRef();
                await setDoc(docRef, { accountType: 'free' }, { merge: true });
                window.userAccountType = 'free';
                updateAppTheme();
                window.renderStacks();
                showModal('Downgraded to Free', '<p class="text-yellow-400 font-bold">You are now on the Free tier.</p><p>You may encounter advertisements and are limited to 5 stacks.</p>', null, false);
            } catch (error) {
                showModal('Error', `Failed to downgrade status: ${error.message}`);
            }
        };

        /**
         * Primary function triggered by the main button. Checks status and shows appropriate modal.
         */
        window.handleProToggle = () => {
            if (window.userAccountType === 'free') {
                showPaymentModal();
            } else {
                 showModal(
                    'Confirm Downgrade',
                    '<p class="text-lg font-semibold">Are you sure you want to cancel your PRO subscription?</p><ul class="list-disc list-inside mt-2 text-red-300"><li>Ads will return immediately.</li><li>You will be limited to 5 stacks.</li><li>You will lose advanced dashboard features.</li></ul>',
                    window.performFreeDowngrade,
                    true
                );
            }
        };


        // UI function to update colors and buttons based on status
        function updateAppTheme() {
            const toggleButton = document.getElementById('toggleProButton');
            
            if (window.userAccountType === 'pro') {
                toggleButton.textContent = 'Manage Subscription (PRO Active)';
                toggleButton.classList.remove('bg-yellow-500', 'hover:bg-yellow-600', 'text-gray-900');
                toggleButton.classList.add('bg-gray-500', 'hover:bg-gray-600', 'text-white');
                document.getElementById('welcomeMessage').textContent = "Welcome back, PRO Stacker!";
            } else {
                toggleButton.textContent = `Go PRO! Unlock Streaks for ${PRO_PRICE}/mo (Ad-Free)`; // Price update applied here
                toggleButton.classList.remove('bg-gray-500', 'hover:bg-gray-600', 'text-white');
                toggleButton.classList.add('bg-yellow-500', 'hover:bg-yellow-600', 'text-gray-900');
                document.getElementById('welcomeMessage').textContent = "Start Building Your Routine!";
            }
        }


        // Listen for real-time changes
        function startHabitListener() {
            if (!isAuthReady || !db || !auth.currentUser) return;

            const stacksQuery = query(getStacksCollectionRef());

            onSnapshot(stacksQuery, (snapshot) => {
                const fetchedStacks = [];
                snapshot.forEach(doc => {
                    fetchedStacks.push({ id: doc.id, ...doc.data() });
                });
                window.habitStacks = fetchedStacks; 
                window.renderStacks(); 
            }, (error) => {
                console.error("Error listening to stacks:", error);
            });
        }

        /**
         * Adds a new stack to Firestore. Check for limits first.
         * ADDED SAFETY CHECK HERE: if (!isAuthReady || !db || !auth.currentUser)
         */
        window.addStackToDB = async (trigger, action) => {
            if (!isAuthReady || !db || !auth.currentUser) {
                showStackMessage("Waiting for database connection. Please try again in a moment.", 'error');
                console.warn("Attempted to add stack before auth was ready.");
                return false; 
            }
            
            if (window.userAccountType === 'free' && window.habitStacks.length >= MAX_FREE_STACKS) {
                showModal('Stack Limit Reached', `<p class="text-red-300 font-bold">Free accounts are limited to ${MAX_FREE_STACKS} stacks.</p><p>Please delete an existing stack or upgrade to PRO to continue adding more.</p>`);
                return false; 
            }

            try {
                await addDoc(getStacksCollectionRef(), {
                    trigger: trigger,
                    action: action,
                    createdAt: new Date().getTime(),
                    isCompleteToday: false, 
                    streakCount: 0,         
                    lastCompletedDate: null   
                });
                showStackMessage("Success! Stack added.", 'success');
                return true; 
            } catch (error) {
                showStackMessage(`Error adding stack: ${error.message}`, 'error');
                return false;
            }
        };

        /**
         * Deletes a stack from Firestore.
         */
        window.deleteStackFromDB = async (id) => {
            if (!isAuthReady || !db) return console.error("Database not ready.");
            try {
                const stackDocRef = doc(getStacksCollectionRef(), id);
                await deleteDoc(stackDocRef);
            } catch (error) {
                showModal('Error', `Failed to delete stack: ${error.message}`);
            }
        };

        /**
         * Updates the habit's completion status and streak.
         */
        window.toggleHabitCompletion = async (stack) => {
            if (!isAuthReady || !db) return console.error("Database not ready.");
            
            const docRef = doc(getStacksCollectionRef(), stack.id);
            const today = new Date().toISOString().split('T')[0];
            
            let newStreak = stack.streakCount || 0;
            let newLastCompletedDate = stack.lastCompletedDate;
            let newIsCompleteToday = !stack.isCompleteToday;
            
            if (newIsCompleteToday) {
                const yesterday = new Date(Date.now() - 86400000).toISOString().split('T')[0];
                
                if (stack.lastCompletedDate === yesterday || stack.lastCompletedDate === null) {
                    newStreak++;
                } else if (stack.lastCompletedDate !== today) {
                    newStreak = 1;
                }
                newLastCompletedDate = today;

            } else {
                if (stack.lastCompletedDate === today) {
                    newStreak = Math.max(0, newStreak - 1);
                    newLastCompletedDate = null;
                }
            }

            try {
                await updateDoc(docRef, {
                    isCompleteToday: newIsCompleteToday,
                    streakCount: newStreak,
                    lastCompletedDate: newLastCompletedDate
                });
            } catch (error) {
                console.error("Error updating document:", error);
            }
        };

        // --- Payment Modal Logic ---
        function showPaymentModal() {
            const paymentContent = `
                <div class="space-y-4">
                    <h4 class="text-3xl font-extrabold text-cyan-400">Stack & Grow PRO</h4>
                    <p class="text-xl font-bold text-white mb-4">${PRO_PRICE} / month</p>
                    
                    <p class="text-gray-300">Unlock your full potential with an ad-free, unlimited stacking experience.</p>
                    
                    <ul class="list-none space-y-2 text-left text-gray-200">
                        <li class="flex items-center">
                            <svg class="w-5 h-5 mr-2 text-green-400" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clip-rule="evenodd"></path></svg>
                            Unlimited Habit Stacks
                        </li>
                        <li class="flex items-center">
                            <svg class="w-5 h-5 mr-2 text-green-400" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clip-rule="evenodd"></path></svg>
                            Ad-Free Tracking
                        </li>
                        <li class="flex items-center">
                            <svg class="w-5 h-5 mr-2 text-green-400" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clip-rule="evenodd"></path></svg>
                            Advanced Streak & History Dashboard
                        </li>
                    </ul>
                </div>
            `;

            showModal('Upgrade to PRO', paymentContent, () => {
                // Simulate redirect to payment provider and successful payment
                showModal('Processing Payment...', '<p>You would now be redirected to a secure payment page (e.g., Stripe/PayPal) to enter your details.</p><p class="text-yellow-400 font-medium mt-2">Simulating successful payment...</p>');
                
                // Wait briefly, then execute the upgrade
                setTimeout(() => {
                    window.performProUpgrade();
                }, 1500);

            }, true); // Use the confirmation button setup
            
            // Override the default confirm button text and style
            const footer = document.getElementById('modalFooter');
            const confirmBtn = footer.querySelector('.bg-cyan-600');
            if (confirmBtn) {
                confirmBtn.textContent = `Pay ${PRO_PRICE} / month`; 
                confirmBtn.classList.remove('bg-
